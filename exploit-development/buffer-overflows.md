# Buffer Overflows

Understanding what a buffer overflow is and the difference between a stack and heap buffer overflow is covered first. This is necessary in order to understand how to exploit these flaws and a fundamental building block for information security.

### Understanding Buffer Overflow

A buffer is a data or memory holding area used to house data. The condition that causes a buffer overflow is when data is exceeding the allotted size of the buffer and thus overflows into other memory areas within the program. Think of two 5L buckets next to one another as the buffers and water as the data. When one bucket is filled with more than 5L of water the water will overflow out into the other 5L bucket. This is an over simplified analogy of a buffer overflow however, it illustrates the basic concept. Where these buffers are located will determine the type of buffer overflow attack; either a _stack buffer overflow_ or a _heap buffer overflow_.

#### Stack Buffer Overflow

**Memory Architecture**

Brown and Stallings \(2015\) defined the stack buffer overflow attack as “when the targeted buffer is located on the stack, usually as a local variable in a function’s stack frame” \(p. 342\). In order to understand what a stack buffer overflow is the stack must be examined and understood. As a program is initialized the central processing unit \(CPU\) allocates virtual memory to the program’s processes. The allocated memory is organized into the following sections: text, data \(initialized data and uninitialized data\), stack and heap. The CPU provides each process with its own virtual address space. The structure for each of these regions is shown in figure 1. Depending on CPU architecture the stack is allocated either at the bottom or top of the address space and either grows upward or downward. The stack area and heap grow in opposite directions into the spare memory allocation. The stack area is a Last In First Out \(LIFO\) data structure in which a stack of objects are pushed onto the stack with the last object becoming the first object to be popped off of the stack. The term PUSH and POP are operations used to add or remove objects from the stack. Imagine 5 boxes that need to be stacked on top of each other. Then there is a need for the 3rd box. Taking the box directly out would cause the top 2 boxes to fall. To prevent that from

```text
0xffffffff +---------------+ <- Top of
| Kernel code | Memory Address
^ | and data |
| +---------------+
| | |
| | | |
| | Stack | |
| | v |
| | |
| +---------------+
| | |
| | Free |
+ | memory |
| |
(if 32-bit) +---------------+
| |
^ | ^ |
| | Heap | |
| | | |
| | |
| +---------------+
| | Uninitialized |
| | data |
| +---------------+
| | Initialized |
| | data |
+ +---------------+
| Text | Bottom of
0x00000000 +---------------+ <- Memory Address
```

```text
Figure 1 Memory Structure of a Program
```

happening the top 2 boxes are popped off the stack. The stack is used to keep track of functions, procedures that the program is running as well as any parameters or local variables that the function needs. When this data that is saved on the stack and a function is called a new structure is created called a stack frame. The stack frame is used to support the execution of the function being called. The stack frame contains a return address, local variables and any arguments passed to the function. The return address is used to return control back when the function finishes. This information is stored in CPU registers; which are small sets of data stores which are part of the processor. Registers are used to store instruction, data or memory addresses that the processor can access quickly. Microprocessors use general purpose registers for storing both data and addresses. Some important general-purpose registers are _sp_ \(stack pointer\), _bp_ \(base pointer\), and _ax_ \(the accumulator\). For 16-bit processor architectures and for 32-bit processors the general-purpose registers are _esp_ \(extended stack pointer\), _ebp_ \(extended base pointer\), and _eax_ \(extended accumulator\). The prefix “E” representing the registers were increased to 32-bits in x86 assembly language. The first register _esp_ is the _stack pointer_ , and this register stores the address to the top of the stack. As objects are pushed and popped onto the stack the address that is stored in _esp_ changes. Next is the _ebp_ register, or the _base pointer_ which contains a fixed address at the base of the stack

frame of the current function that is running. The _ebp_ register is a reference point for the access of arguments and local variables and only changes when another function is called or ends. Lastly, the _eax_ register or the accumulator register which is used in storing the return value of a function and also used in arithmetic instructions. Figure 2 displays a single stack frame and the relation to these CPU registers. To successfully exploit a stack buffer overflow the return address on the stack must be overwritten. This is achieved by overflowing local variables within the _local buffer_ in figure 2. Overflowing the _local buffer_ variable will overwrite the return address and create a new return address. This can cause issues when the return address is only partially overwritten and cause the stack to become misaligned. Determining the spacing or offset between the local variable and the return address will aid in keeping the stack aligned.

```text
+----------CPU Registers-----------+
+-------+ +-------+ +------+
| esp | | ebp | | eax |
| stack | | frame | |return|
|pointer| |pointer| +value |
+---+---+ +---+---+ +------+
| |
+---+ +------+
| |
V V
+---------+--------+------------+-------+-------+
| Local | Saved | Return | | |
| buffer | ebp | address | param | param |
| | | | | |
+---------+--------+------------+-------+-------+
(12bytes) (4bytes) (4bytes) (4bytes) (4bytes)
<---------------+ +-------------------->
Stack growth Higher memory addresses
Figure 2 Stack Frame and CPU Registers
```

With the buffer offset determined a malicious payload can be crafted. The payload will overflow the local variable and return address with a different return address and inject shellcode successfully exploiting the program.

**Test Program**

Below in Figure 3 is the source code to a test program that is vulnerable to a stack buffer overflow. Since the stack frame contains local variables and arguments passed to the function, examining the stack layout will assist in determining how to exploit this program.

```text
#include <stdio.h>
#include <stdlib.h>
```

```text
int maliciousFunction(char* param)
{
char* localVar = "Delicious Malicious";
int localInt = 0xcafebabe;
char localString[10];
```

```text
strcpy(localString, param);
```

```text
return 1;
}
```

```text
int main(int argc, char* argv[])
{
char* localVar = "Main function";
int localInt = 0x11223344;
```

```text
maliciousFunction(argv[1]);
```

return 0; } _Figure 3 Test Program Source Code for Stack Buffer Overflow_

In this source code above there are two functions; the _main_ function and the maliciousFunction function. When the maliciousFunction is called the two parameters that _strcpy_ wants are pushed onto the stack. The parameter localString is the destination and second parameter, param is the source. The local variables of the main function are already stored on the stack and are pushed onto the stack first. The overflow occurs when a user supplies an argument larger than the local variable, localString can handle. Passing an argument of 32 “A” characters will crash the program and cause a core dump. The characters have successfully overwritten the frame pointer and return address. With the return address overwritten with “A’s” the program will attempt to return to an address of _0x41414141_ which is the hexadecimal representation of “AAAA”.

#### Heap buffer overflow

The heap is dynamic and memory is allocated at run-time and thus memory is not allocated in contiguous order. Making the heap suitable for larger objects, structures or arrays. For items that are needed to live outside their defining brackets the heap is needed to store these items. Because of this overhead heap variables are slower than stack variables.

**Memory Architecture**

Unlike the stack, the heap grows upward toward higher memory addresses. Since heap memory is set aside for dynamic allocation there is no enforced pattern of allocation or deallocation of memory blocks on the heap.

```text
+--------------------------------+ Top of Stack
| 0xbffff070 0xbffff330 |
| param ---> localString | |
| (4bytes) (4bytes) | |
| esp Stack Pointer Register | |
| | | Stack Grows in
| 0xbffff088 | | this direction
| localInt ---> 0x11223344 | |
| (4bytes) (4bytes) | |
| | |
| | |
| 0xbffff08c 0x8048524 | |
| localVar ---> "Main function"| |
| (4bytes) (4bytes) | v
+--------------------------------+
| Saved Return Address |
| (4bytes) |
+--------------------------------+
| Saved frame pointer |
| (4bytes) | +----------------------------+
+--------------------------------+ | An overflow occurs |
| | | when the buffer receives |
| Buffer | | a string larger the 32 |
| (32bytes) | | |
| | +----------------------------+
+--------------------------------+
Figure 4 Stack Layout with Parameters and Buffer
```

```text
Figure 5 Heap Memory Architecture
```

```text
High address +------------------------+
0xffffffff | |
| Free |
^ | memory |
| | |
| +------------------------+
| | |
| | ^ ^ |
| | | Heap | |
| | (grows upwards) |
(if 32|bit) | |
| +------------------------+
| | BSS |
| | Uninitialized ^ariables|
| +------------------------+
| | Data |
| | Initialized Variables |
+------------------------+
Low address | Text |
0x00000000 +------------------------+
```

**Test Program**

Below is the source code for the test program that contains a heap buffer overflow vulnerability. This test program only has one function main and the variables p1 and p2 are assigned to malloc\(\) function. From the man page, “the malloc\(\) function is used to allocate size bytes and returns a pointer to the allocated memory.” Free Software Foundation \(2019\). The function free\(\) then frees the space pointed to by the pointer and returned by a previous call to malloc\(\).

The structure of the heap contains both allocated memory, unallocated memory fragments and metadata. These regions of memory are divided into “chunks” of various sizes. Each chunk contains information about its size and where the adjacent chunks are located. Figure 7 shows how allocated and non-allocated chunks are structured in the heap.

```text
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
```

```text
int main(int argc, char** argv)
{
```

```text
char *p1, *p2;
```

```text
p1 = malloc(16);
p2 = malloc(1024);
```

```text
if (argc > 1)
strcpy(p1, argv[1]);
```

```text
free(p2);
free(p1);
```

```text
return 0;
}
```

```text
Figure 6 Source Code for Heap Buffer Overflow
```

```text
Heap
+---------------+
+---> | |
| | |
+ +---------------+
Allocated +---------------+
memory | |
+ +---------------+
| | |
+---> | |
+---------------+
+---------------+
+---> | |
| | |
| +---------------+
+ | |
Unallocated | |
fragments | |
+ +---------------+
| | |
| +---------------+
+---> | |
| |
+---------------+
| |
+---------------+
Metadata +--> +---------------+
Figure 7 Allocated and Non-allocated Chunks
```

The memory is carved into chunks with the first field of the chunks giving its size. These fields are 4-bytes in size and each chunk is divisible by 8 \(Lea, 1996\). Figure 8 displays two allocated chunks that reside on the heap.

With a heap buffer overflow the data portion of a chunk overflows into adjacent chunks. Overwriting the segment of the chunk that contains the previous chunk size and the size of the chunk. If the chunk overflows into chunk that is allocated then when the free function is called it will look to the overwritten chunk section for the previous chunk size and the chunk size information in order to free up memory. If a bad value is put into these locations, the program flow can be controlled. The free function may try to access these bad values. Figure 9 shows a heap chunk overflowing into another chunk with the “A” character.

```text
X+------------------------+
X | Heap Segment |
X | +--------------------+ |
X | |Previous Chunk Size | | +
0x00000000 X | | (4 bytes) | | |
+--------------X | +--------------------+ | |
| | | | Chunk Size | | |
| Heap | | | (4 bytes) | | |
| | | +--------------------+ | |
+--------------+ | | Data | | |
| | | | (8+(n/8)*8 bytes) | | | Grows towards
| | | +--------------------+ | | higher memory
+--------------+ | | Previous Chunk Size| | |
| | | | (4 bytes) | | |
| Stack | | +--------------------+ | |
| | | | Chunk Size | | |
+--------------X | | (4 bytes) | | |
0xffffffff X | +--------------------+ | |
X | | Data | | v
X | | (8+(n/8)*8 bytes) | |
X | +--------------------+ |
X+------------------------+
```

```text
Figure 6 Two Allocated Chunks on the Heap
```

```text
+-----------------------+
| Heap Segment |
| |
| +-------------------+ | |
| |Previous Chunk Size| | |
| +-------------------+ | |
| | Chunk Size | | |
| +-------------------+ | |
| |AAAAAAAAAAAAAAAAAAA| | |
| |AAAAAAAAAAAAAAAAAAA| | |
| |AAAAAAAAAAAAAAAAAAA| | |
| |AAAAAAAAAAAAAAAAAAA| | |
| |AAAAAAAAAAAAAAAAAAA| | | Grows towards
| |AAAAAAAAAAAAAAAAAAA| | | higher memory
| |AAAAAAAAAAAAAAAAAAA| | |
| | | | |
| | HEAP OVERFLOW | | |
| +-------------------+ | |
| | Chunk Size | | |
| +-------------------+ | |
| | | | |
| | Data | | |
| | | | v
| +-------------------+ |
| |
+-----------------------+
```

```text
Figure 7 Heap Chunk Overwritten
```

### Exploiting Buffer Overflow...........................................................................................

#### Exploit Screenshot

Exploiting the _sort_ program provided was performed on a Kali Linux OS, 64 bit, kernel version 4.19.0-kalil-amd64.

**Screenshot of Exploit Payload**

**Screenshot of Exploiting Sort Program**

### Open Question

Explain the similarity and difference between Jump-Oriented Programing and Return- Oriented Programming.

Return-Oriented Programming \(ROP\) and Jump-Oriented Programming \(JOP\) both are examples of code re-use attacks in which exploitation of the program relies on executing code already present in memory. Both ROP and JOP manipulate the control-flow of the program to allow entry in any memory address of a library or executable program. \(Bletsch et al., 2011\) ROP and JOP also rely heavily on short snippets of code called _gadgets._ However, the utilization of these _gadgets_ is where ROP and JOP differ significantly. ROP utilizes the ret instruction to direct the control-flow of a program and JOP utilizes jmp instructions to direct the control-flow of a program. By utilizing the ret instruction, ROP chains together _gadgets_ ending with the ret instruction making the stack pointer act as a “program counter”. JOP is not limited to the stack pointer because it does not rely on the ret instruction. Instead JOP can use any register to act as a “program counter” by utilizing jmp instruction. Not having to rely on the stack pointer for control-flow affords JOP the advantage to use any memory range.

#### References

Brouwer, A. \(2003\). Exploiting the head. Available at [https://www.win.tue.nl/~aeb/linux/hh/hh-11.html](https://www.win.tue.nl/~aeb/linux/hh/hh-11.html) \(February 06, 2019\) Free Software Foundation \(2019\) ‘Malloc manual page’, Linux \(Ubuntu\). Available at [http://man7.org/linux/man-pages/man3/malloc.3.html](http://man7.org/linux/man-pages/man3/malloc.3.html) \(February 06, 2019\) Stallings, W., & Brown, L. \(2015\). Chapter 10/Buffer Overflow. In Computer security principles and practice \(p. 342\). Boston, MA: Pearson. Lea, D. \(1996\). A Memory Allocator. Available at [http://gee.cs.oswego.edu/dl/html/malloc.html](http://gee.cs.oswego.edu/dl/html/malloc.html) \(February 06, 2019\) Bletsch, T., Jiang, X., Freeh, V. W., & Liang, Z. \(2011\). Jump-oriented programming. Proceedings of the 6th ACM Symposium on Information, Computer and Communications Security - ASIACCS '11. doi:10.1145/1966913.

